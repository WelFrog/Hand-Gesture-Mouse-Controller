# 设计原理与关键技术实现

## 1. 鼠标控制性能优化：C++ DLL 集成

### 1.1. 性能瓶颈分析
在手势控制应用中，实时性至关重要。使用 Python 库（如 `pyautogui`）进行鼠标操作时，通常涉及到跨进程通信或较高层级的 API 调用，这会引入额外的延迟和性能损耗，导致光标移动不跟手（Lagging）。

### 1.2. 解决方案：DLL 封装
为实现低延迟操作，本项目采用以下策略：
* **C++ 封装:** 使用 C/C++ 编写底层鼠标控制逻辑。C++ 代码直接调用 Windows API 函数（如 `SendInput`）来模拟鼠标事件，避免了高级抽象带来的开销。
* **ctypes 桥接:** Python 主程序通过内置的 `ctypes` 库加载并调用编译好的动态链接库 (`MouseController.dll`)。这使得 Python 能够以近乎原生的速度执行 C++ 代码，从而实现毫秒级的响应速度。

## 2. 智能光标移动算法

### 2.1. 移动状态判断机制
光标的移动需要一个明确的开关状态，以区分操作手势和普通手部姿态。本项目通过监测手部关键点之间的距离来实现“锁住”移动状态：

* **激活条件:** 当无名指尖 (`RING_FINGER_TIP`) 和小指尖 (`PINKY_TIP`) 同时向手腕方向收拢时，激活移动状态 (`is_moving = True`)。
* **判断公式:** 我们设定一个阈值（例如 0.2），当两个手指尖到手腕 (`WRIST`) 的归一化距离均小于此阈值时，即判断为握拳状态。
    $$
    D_{ring} < 0.2 \quad \text{and} \quad D_{pinky} < 0.2
    $$
    其中 $D$ 代表归一化欧氏距离。

### 2.2. 指数平滑 (Exponential Smoothing)
手部在空中移动不可避免地存在细微抖动。为了实现平滑移动，本项目应用了指数平滑算法来处理手腕的位移向量。

* **目的:** 消除高频噪声，使光标移动轨迹平稳过渡。
* **算法实现:** 每一帧计算出的鼠标位移量 ($\Delta_{\text{input}}$) 不会直接应用，而是与上一帧的速度 ($V_{\text{old}}$) 进行加权平均，得到当前帧的速度 ($V_{\text{new}}$)。
    $$
    V_{\text{new}} = \alpha \cdot V_{\text{old}} + (1 - \alpha) \cdot \Delta_{\text{input}}
    $$
    其中：
    * $V_{\text{new}}$: 当前帧的平滑后速度。
    * $V_{\text{old}}$: 上一帧的速度。
    * $\Delta_{\text{input}}$: 当前帧计算出的手腕位移对应的鼠标位移（未平滑）。
    * $\alpha$: 平滑系数，本项目设置为 $\mathbf{0.8}$。$\alpha$ 越大，平滑效果越强，但响应延迟也略高。

### 2.3. 加速机制 (Acceleration Factor)
为了让用户的手部移动效率更高，引入了加速因子 (`acceleration_factor`)。

* **目的:** 将用户手部的小范围移动映射到屏幕较大的像素位移，减少手臂疲劳。
* **应用:** 手腕的归一化位移 ($\Delta_{\text{hand}}$) 在映射到屏幕像素位移 ($\Delta_{\text{mouse}}$) 时，乘以屏幕尺寸和加速因子。
    $$
    \Delta_{\text{mouse}, x} = \Delta_{\text{hand}, x} \times \text{ScreenWidth} \times \text{AccelerationFactor}
    $$
    本项目中 `acceleration_factor` 设置为 $\mathbf{2.0}$。

## 3. 粘滞拖动模式 (Sticky Mode)

### 3.1. 捏合识别
点击操作通过监测大拇指尖 (`THUMB_TIP`) 和食指尖 (`INDEX_FINGER_TIP`) 的相对位置来实现捏合（Pinch）手势。当两关键点之间的 $x, y$ 差异均小于特定阈值（例如 0.05）时，判定为捏合。

### 3.2. 粘滞模式设计
传统的点击手势在需要拖动（如拖动窗口或选择文本）时，要求用户长时间保持精确的捏合姿态，容易导致肌肉疲劳和姿态抖动引起的误释放。粘滞模式解决了这个问题。

| 状态 | 触发条件 | 效果 |
| :--- | :--- | :--- |
| **进入粘滞** | 持续捏合时间 $\ge 0.5$ 秒 | 强制保持鼠标左键按下（`mouseDown()`），用于启动拖动。 |
| **退出粘滞** | 持续松开时间 $\ge 0.3$ 秒 | 释放鼠标左键（`mouseUp()`）。 |

这种双计时机制确保一旦开始拖动，即使手部在拖动过程中略有放松，也不会立刻中断左键，极大地提升了拖动操作的稳定性和用户体验。

## 4. 操作手追踪与稳定性

在多手或手部短暂离开视野时，需要机制来维持操作的一致性。

### 4.1. 目标锁定原则
当 `results.multi_hand_landmarks` 返回多个手部数据时，系统不会随机选择。它会依据 **最小距离原则** 来确定当前帧的操作手：

* **追踪目标:** 记录上一帧被识别为操作手的**手腕关键点位置** (`operation_hand_wrist`)。
* **选择逻辑:** 在当前帧检测到的所有手腕中，选择与上一帧 `operation_hand_wrist` 具有最小欧氏距离的手作为新的操作手。
* **优势:** 确保了操作手在连续帧中的一致性，即使另一只手进入或退出视野，也不会导致光标控制权的意外转移。